// string.rf idea using c allocation instead of an arena

native void* malloc(long size);
native void* realloc(void* block, long size);
native void* calloc(int count, int elem_size);
native void* memset(void* block, int ch, int size);
native void  memcpy(void* to, void* from, int size);
native void  memmove(void* to, void* from, int size);
native void  free(void* buffer);

namespace std {
    struct string {
        char *data;
        int length;
        // NOTE(EVERYONE): the implementation of length does not include the '\0' at the end
    }

    static void alloc_str(string *str, int length) {
        str->data = (char *) malloc(length * sizeof(char));
    }

    static void realloc_str(string *str, int length) {
        str->data = (char *) realloc(str, length * sizeof(char));
    }

    char *get_cstr(string str) {
        return str->data;
    }

    // it's really best if you use this; empty_string could segfault
    string get_str(cstring data) {
        string ret = { .data = nullptr; .length = 0; };
        while (data[ret.length]) {
            ret.length++;
        }

        alloc_str(&ret, ret.length + 1);
        memcpy(ret.data, data, ret.length + 1);

        return ret;
    }

    void set_str(string *str, char *data) {
        str->length = 0;
        while (data[str->length]) {
            str->length++;
        }

        realloc_str(str, str->length + 1);
        memcpy(ret.data, data, ret.length + 1);
    }

    void set_str(string *str_dest, string *str_src) {
        str_dest->length = str_src->length;

        realloc_str(str, str->length + 1);
        memcpy(ret.data, str_src->data, ret.length + 1);
    }

    // i call it empty and not free bc the 10-12 bytes making the cstring itself aren't being freed
    // but the data is; it's up to the developer to manage alloc'ed cstring instances themselves
    void empty_string(string *str) {
        free(str->data);
        str->length = 0;
    }
}
